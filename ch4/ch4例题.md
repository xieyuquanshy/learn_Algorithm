2020年10月21日12:40:54

## Uva 1339
对一个字符串s进行重排，然后对每个字符进行一一映射，然后问你能不能转换成字符串t。因为是一一映射，所以对于s中的每个字符s[i]，都有t[j]与它对应，
而且cnt[s[i]] = cnt[s[j]]，那么就分别记录下s和t每个字符出现的个数，然后排序比较是否完全相等即可。

## Uva 489
一行是电脑给出的字符串s，一行用户输入的字符串p。判定规则：
1. 当用户猜的字符是属于s的，那么s中所有的这个字符都显示solved。
2. 用户最多只能错6次，超过6次就是失败。
3. 重复猜猜过的字符也算错。
4. 在6次错误内猜出所有字符，才算赢。

模拟就行了。

## Uva 113
其实就是个变种约瑟夫问题，搞了半天竟然没搞出来，太菜了。
一个顺时针走m次，一个逆时针走k次，不再同一位置的话就输出两次，否则只输出
一次。

## Uva 213
这题的输入最恶心的，只要把输入写好就差不多了。

## Uva 512
大模拟，按题目模就完事了，要小心！

## Uva 12412
这道题不难，但很烦，慢慢写注意细节。

## Uva 12108
因为题目数据范围并不大，所以可以枚举时间t[1...10000]，然后判断每个时间点是否有全清醒的时刻。

## Uva 201
注意输入V i j 的时候需要行列转换，然后枚举就行了。

## Uva 220
暴力枚举就行了，没什么技术含量，注意细节😆。

## Uva 253
模拟骰子旋转后的样子，然后判断即可。

## Uva 1590
先把数变成二进制串，然后找到第一个不同的位置，这个位置以后的二进制都变成0，然后输出就行。